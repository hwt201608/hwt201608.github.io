<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="LeetCode | 刷题分享"><meta name="keywords" content="LeetCode"><meta name="author" content="Elody"><meta name="copyright" content="Elody"><title>LeetCode | 刷题分享 | Elody的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.2/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类似题目分类"><span class="toc-text">类似题目分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#买卖股票"><span class="toc-text">买卖股票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#旋转排序数组"><span class="toc-text">旋转排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#打家劫舍"><span class="toc-text">打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#众数问题——摩尔投票法"><span class="toc-text">众数问题——摩尔投票法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现计算器问题"><span class="toc-text">实现计算器问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背包问题"><span class="toc-text">背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬币问题"><span class="toc-text">硬币问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态规划"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维动态规划"><span class="toc-text">二维动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些算法笔记"><span class="toc-text">一些算法笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集-—-Disjoint-Set"><span class="toc-text">并查集 — Disjoint Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典树-前缀树"><span class="toc-text">字典树/前缀树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TOP-K问题"><span class="toc-text">TOP K问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回溯法"><span class="toc-text">回溯法</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/Elody-07/PicBed/master/20190527143428.png"></div><div class="author-info__name text-center">Elody</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/Elody-07/PicBed/master/20190527143630.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Elody的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">LeetCode | 刷题分享</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/分享/">分享</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>一只找工作的算法程序媛的刷题一二三。</p>
</blockquote>
<a id="more"></a>
<p>从研一开始有陆陆续续刷题，但是三天打鱼两天晒网的，也没什么刷题体系。最开始是把剑指offer过了一遍，然后刷LeetCode分组里面的“TopInterview” 列表，一开始只刷easy和medium的，就这样还不叫刷题，叫刷题解。一旦间隔时间太长了，就把之前刷过的再刷一遍，这样刷了一两百道吧，看到easy/medium的才不那么怵了，也开始发现有的题目看上去很像，但是解题思路不太一样，后面刷题的时候就会比较注意看LeetCode上“相似题目”的tag，尽量把类似的题目放一起看，思考相同点和不同点，对照着来看映像深刻一点。</p>
<p>最近面临找实习&amp;找工作，开始集中大量刷题，随着刷题越多，忧虑也开始出现，题目只刷一遍通常会在遇到类似的题目时有种抓耳挠腮，感觉明明看过，思路半通不通的情况，所以最近在二刷（有的可能三刷）算法，记了一些题目/解法有点相关的题目，方便自己后面复习。</p>
<h2 id="类似题目分类"><a href="#类似题目分类" class="headerlink" title="类似题目分类"></a>类似题目分类</h2><p><a href="https://www.jianshu.com/p/24895aca0459" target="_blank" rel="noopener">Rabin-Karp算法</a> O(n)时间实现子字符串查找 → 散列(数字表示字符串)+哈希</p>
<ul>
<li>No.187 重复的DNA序列</li>
<li>No.1044 最长重复子串</li>
</ul>
<h3 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h3><ul>
<li>No.121 基础版，一次交易，动态规划</li>
<li>No.122 基础版，无限次交易，贪心</li>
<li>No.123 升级版，两次交易</li>
<li>No.188 终极版，k 次交易</li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/5xing-dai-ma-gao-ding-suo-you-gu-piao-ma-j6zo/" target="_blank" rel="noopener"><strong>绝妙题解</strong></a></li>
</ul>
<h3 id="旋转排序数组"><a href="#旋转排序数组" class="headerlink" title="旋转排序数组"></a>旋转排序数组</h3><ul>
<li>No.33 搜索旋转排序数组；No.81 搜索旋转排序数组 II → 搜索target值</li>
<li>No.153 寻找旋转排序数组中的最小值；No.154 寻找旋转排序数组中的最小值 II → 搜索最小值</li>
<li>No.187 旋转数组</li>
<li>No.61 旋转链表</li>
<li>No.151 翻转字符串里的单词 No.186 翻转字符串里的单词II</li>
</ul>
<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><ul>
<li>No.198 &amp; No.213 基础版，动态规划</li>
<li>No.337 二叉树</li>
</ul>
<h3 id="众数问题——摩尔投票法"><a href="#众数问题——摩尔投票法" class="headerlink" title="众数问题——摩尔投票法"></a>众数问题——摩尔投票法</h3><ul>
<li>No.169 多数元素 出现次数&gt;n/2 次 → 只有1个</li>
<li>No.229 求众数II 出现次数&gt;n/3次 → 最多2个(2, 1, 0)</li>
</ul>
<h3 id="实现计算器问题"><a href="#实现计算器问题" class="headerlink" title="实现计算器问题"></a>实现计算器问题</h3><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul>
<li>No.39 组合总和；No.40 组合总和II → 数字不可重复/可重复</li>
</ul>
<h3 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h3><ul>
<li>No.322 零钱兑换 → 凑成总金额所需的<strong>最少硬币个数</strong></li>
<li>No.518 零钱兑换II → 凑成总金额的组合数</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul>
<li>No.62 不同路径</li>
<li>No.64 最小路径和</li>
<li>No.174 地下城游戏，逆推有点难想到</li>
</ul>
<h3 id="二维动态规划"><a href="#二维动态规划" class="headerlink" title="二维动态规划"></a>二维动态规划</h3><ul>
<li>No.72 编辑距离</li>
<li>No.115 不同的子序列</li>
<li>剑指 Offer 60. n个骰子的点数</li>
</ul>
<h2 id="一些算法笔记"><a href="#一些算法笔记" class="headerlink" title="一些算法笔记"></a>一些算法笔记</h2><h3 id="并查集-—-Disjoint-Set"><a href="#并查集-—-Disjoint-Set" class="headerlink" title="并查集 — Disjoint Set"></a>并查集 — Disjoint Set</h3><ul>
<li>No.323 无向图中连通分量的数目</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=YKE4Vd1ysPI" target="_blank" rel="noopener">视频教程</a></p>
<p>可用于检测图中是否有环：构建图，根据边的关系不断向图中合并节点，具体操作为找到两个顶点的根节点，让一个根节点指向另一个，即合并两个节点。如果合并的两个节点的根节点相同，说明图中有环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.parent = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        self.rank = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.parent[x] != <span class="number">-1</span>:</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx == rooty:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.rank[rootx] &lt; self.rank[rooty]:</span><br><span class="line">            self.parent[rootx] = rooty</span><br><span class="line">        <span class="keyword">elif</span> self.rank[rooty] &lt; self.rank[rootx]:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[rootx] = rooty</span><br><span class="line">            self.rank[rooty] += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="字典树-前缀树"><a href="#字典树-前缀树" class="headerlink" title="字典树/前缀树"></a>字典树/前缀树</h3><ul>
<li>No.820 单词的压缩编码</li>
</ul>
<p>Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构。通常来说，一个字典树是用来存储字符串的。字典树的每一个节点代表一个字符串（前缀）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Elody-07/PicBed/20200408180210.png" alt="https://cdn.jsdelivr.net/gh/Elody-07/PicBed/20200408180210.png"></p>
<ul>
<li><p>前缀树的实现V</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">27</span>)]</span><br><span class="line">        <span class="comment"># 最后一个元素为1表示单词结束</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        isNew = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">            idx = ord(letter)-ord(<span class="string">'a'</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.children[idx] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                isNew = <span class="literal">True</span> <span class="comment"># important！！！</span></span><br><span class="line">                cur.children[idx] = TrieNode()</span><br><span class="line">            cur = cur.children[idx]</span><br><span class="line">        cur.children[<span class="number">26</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len(word) + <span class="number">1</span> <span class="keyword">if</span> isNew <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> word:</span><br><span class="line">            idx = ord(letter)-ord(<span class="string">'a'</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.children[idx] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur.children[idx]</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Doesn't end here</span></span><br><span class="line">        <span class="keyword">if</span> cur.children[<span class="number">26</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.root</span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> prefix:</span><br><span class="line">            idx = ord(letter)-ord(<span class="string">'a'</span>)</span><br><span class="line">            <span class="keyword">if</span> cur.children[idx] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur.children[idx]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>No.207 课程表；No.210 课程表II</li>
</ul>
<p>在图论中，拓扑排序（Topological Sorting）是一个<strong>有向无环图</strong>（DAG, Directed Acyclic Graph）的所有顶点的线性序列，该序列必须满足下面两个条件：1）每个顶点出现且只出现一次；2）若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。<br>以下图为例说明拓扑排序的算法：</p>
<p>1）从图中找到一个没有前驱（入度为0）的顶点；</p>
<p>2）删除该点和与其相邻的有向边；</p>
<p>3）重复以上步骤直到图为空或当前图中不存在没有前驱入度为0的顶点（该情况说明图中必然有环，此图不存在拓扑排序）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Elody-07/PicBed/20200408164957.png" alt="https://cdn.jsdelivr.net/gh/Elody-07/PicBed/20200408164957.png"></p>
<p>拓扑排序可以用BFS或DFS算法实现，其中BFS能够较为直观地知道该图是否为有向无环图以及输出拓扑排序结果，DFS需要定义flag数组，表示该节点是否被访问过、再次访问该节点时与前一次访问是同一个节点（有环）还是不同节点发起的DFS（正常拓扑排序），</p>
<h3 id="TOP-K问题"><a href="#TOP-K问题" class="headerlink" title="TOP K问题"></a>TOP K问题</h3><p>在未排序的数组中找到<strong>第 k 个最大</strong>的元素。三种解法：数组排序，快速选择算法，Min-Heap小根堆。</p>
<p><strong>数组排序</strong></p>
<p>通过快排对数组排序后，下标为 <code>n-k</code> 的元素即为所求。时间复杂度最好O(nlogn)，最差O(n^2)，<strong>平均O(nlogn)</strong>，<strong>空间复杂度O(logn)</strong></p>
<p><strong>Min-Heap小根堆</strong></p>
<p>维护一个k元素的小根堆，遍历数组，当数组元素大于堆顶时，替换堆顶元素，最后的堆顶元素即为第k大的元素，<strong>时间复杂度O(nlogk)，空间复杂度O(k)</strong></p>
<p><strong>快速选择算法</strong></p>
<p>基于快速排序算法的优化，要找到第k大的元素，只要保证下标为 <code>n-k</code> 的元素，在它左边的元素都小于它，右边的元素都大于它。故可以用partition算法实现，只要得到的pivot下标为 <code>n-k</code> 即可。时间复杂度最好O(n)，最差O(n^2)，平均O(n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># partition的两种实现方式，时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, start, end)</span>:</span></span><br><span class="line">    center = arr[start]</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end):</span><br><span class="line">        <span class="keyword">while</span> start &lt; end <span class="keyword">and</span> arr[end] &gt;= center:</span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        arr[start] = arr[end]</span><br><span class="line">        <span class="keyword">while</span> start &lt; end <span class="keyword">and</span> arr[start] &lt;= center:</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">        arr[end] = arr[start]</span><br><span class="line">    <span class="keyword">assert</span> start == end</span><br><span class="line">    arr[start] = center</span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下标&lt;i的元素值&lt;center，下标为i的元素是第一个&gt;=center的值，故最后center要放在i位置</span></span><br><span class="line"><span class="comment"># 易于扩展为3-way-partition</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, start, end)</span>:</span></span><br><span class="line">    i, j = start, start</span><br><span class="line">    center = nums[end]</span><br><span class="line">    <span class="keyword">while</span> j &lt; end:</span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; center:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    nums[i], nums[end] = nums[end], nums[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-way-partition</span></span><br><span class="line"><span class="comment"># 下标&lt;i的元素值&lt;mid_val，下标&gt;k的元素值&gt;mid_val，其他等于mid_val</span></span><br><span class="line">    i, j, k = <span class="number">0</span>, <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= k:</span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; mid_val:</span><br><span class="line">            nums[j], nums[k] = nums[k], nums[j]</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[j] &lt; mid_val:</span><br><span class="line">            nums[j], nums[i] = nums[i], nums[j] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>一个变体如下：</strong></p>
<p>No.324 摆动排序</p>
<p>该算法的核心是将<strong>数组排序</strong>后分为A（较小组），B（较大组）两组，且len(A) ≥ len(B)，为了实现摆动排序，需要将B组元素隔一个位置插入A组中。为了保证将A，B组的重复元素（A的尾部，B的头部）分开，可以将A、B<strong>反序后再穿插（时间复杂度O(n)，空间复杂度O(n)）</strong>。</p>
<p>优化的思想在于数组排序部分，严格的数组排序可以使用快速排序，平均时间复杂度O(nlogn)；</p>
<p>但事实上该问题<strong>不要求严格排序</strong>，只需要：A、B的重复元素（即数组中位数）在A的尾部，B的头部，且A的元素都小于B的元素即可。这样可以先找到数组的中位数（利用topK问题的思路，找到数组第n//2大的元素即为中位数），再根据中位数做3-way-partition，小于中位数的都在左边，大于中位数的都在右边，这样就实现了数组的粗略排序，后续只需要重复反序、穿插的操作即可。这种思路关键算法中：快速排序算法找数组中位数的平均时间复杂度O(n)，3-way-partition时间复杂度O(n)，反序、穿插时间复杂度O(n)，空间复杂度O(n)，故总体时间复杂度O(n)，空间复杂度O(n)。</p>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>一般可以分为主函数和core函数：<strong>主函数</strong>中检查无效输入，确定递归起点，当起点可以从任一点开始时，主函数加循环；<strong>core函数</strong>中注意判断终止递归的条件，注意勿重复访问，设置visited数组以免进入死循环，并注意core函数return前是否需要重置visited数组。</p>
<p>不需要重置visited数组，所有元素只访问一次：</p>
<p>No.13 机器人的运动范围</p>
<p>包含多个答案，core函数返回前需要重置数组，以免影响其他结果：</p>
<p>No.17 电话号码的字母组合</p>
<p>No.46 全排列</p>
<p>No.79 单词搜索</p>
<p>No.131 分割回文串</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Elody</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://Elody-07.github.io/LeetCode刷题分享/">http://Elody-07.github.io/LeetCode刷题分享/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Elody-07.github.io">Elody的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/PaperReading/"><span>Paper Reading | Hand/Human Pose Estimation</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '469ba2f7e3f141d184ef',
  clientSecret: 'bd3d0f47672ec65ff080c45634fd09a77ac692b9',
  repo: 'Elody-07.github.io',
  owner: 'Elody-07',
  admin: 'Elody-07',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2021 By Elody</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>